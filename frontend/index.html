<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rust Backend Smoke UI</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f4f7fb;
      --card: #ffffff;
      --text: #1a2433;
      --muted: #526179;
      --line: #d6dfeb;
      --accent: #0b64d8;
      --warn: #9a6700;
      --ok: #0a7c45;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font: 14px/1.4 "SF Mono", Menlo, Consolas, monospace;
      background: linear-gradient(180deg, #edf3fb 0%, var(--bg) 100%);
      color: var(--text);
    }

    main {
      max-width: 1100px;
      margin: 20px auto;
      padding: 0 14px 20px;
      display: grid;
      gap: 12px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 12px;
    }

    h1, h2 {
      margin: 0 0 10px;
      font-weight: 700;
      font-size: 16px;
    }

    h1 small {
      display: block;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 400;
    }

    .grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    label {
      display: grid;
      gap: 6px;
      color: var(--muted);
      font-size: 12px;
    }

    input, textarea, select, button {
      font: inherit;
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 8px;
      width: 100%;
      background: #fff;
      color: var(--text);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: end;
    }

    .row > * { flex: 1 1 180px; }
    .row button { flex: 0 0 auto; min-width: 120px; }

    button {
      cursor: pointer;
      border-color: #0d5ac0;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
    }

    button.secondary {
      background: #fff;
      color: var(--text);
      border-color: var(--line);
      font-weight: 500;
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      background: #f6f9fc;
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 10px;
      min-height: 96px;
      max-height: 380px;
      overflow: auto;
    }

    .hint { color: var(--muted); font-size: 12px; }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
  </style>
</head>
<body>
<main>
  <section class="card">
    <h1>
      Rust Backend Smoke UI
      <small>Minimal frontend to manually test API + websocket endpoints.</small>
    </h1>
    <div class="grid">
      <label>Base URL
        <input id="base-url" value="http://localhost:8080" />
      </label>
      <label>Access Token (JWT)
        <input id="access-token" placeholder="Paste token from /api/auth/login response" />
      </label>
      <label>CSRF Token (for cookie refresh/logout)
        <input id="csrf-token" placeholder="Optional x-csrf-token value" />
      </label>
    </div>
    <p class="hint">Use <code>python3 -m http.server 3000 -d frontend</code> so CORS matches <code>http://localhost:3000</code>.</p>
  </section>

  <section class="card">
    <h2>IDs For Route Placeholders</h2>
    <div class="grid">
      <label>User ID
        <input id="user-id" placeholder="uuid" />
      </label>
      <label>Category ID
        <input id="category-id" placeholder="uuid" />
      </label>
      <label>Equipment ID
        <input id="equipment-id" placeholder="uuid" />
      </label>
      <label>Photo ID
        <input id="photo-id" placeholder="uuid" />
      </label>
      <label>Conversation ID
        <input id="conversation-id" placeholder="uuid" />
      </label>
      <label>Participant User ID
        <input id="participant-id" placeholder="uuid" />
      </label>
    </div>
  </section>

  <section class="card">
    <h2>HTTP Request Console</h2>
    <div class="row">
      <label>Endpoint Preset
        <select id="request-presets"></select>
      </label>
      <button id="load-preset" class="secondary" type="button">Load Preset</button>
    </div>
    <div class="row">
      <label>Method
        <input id="request-method" value="GET" />
      </label>
      <label>Path
        <input id="request-path" value="/health" />
      </label>
      <label>Auth Header
        <select id="use-auth">
          <option value="yes">Use Authorization</option>
          <option value="no">No Authorization</option>
        </select>
      </label>
      <button id="send-request" type="button">Send Request</button>
    </div>
    <label>JSON Body
      <textarea id="request-body">{}</textarea>
    </label>
    <div class="row">
      <button id="quick-health" class="secondary" type="button">GET /health</button>
      <button id="quick-ready" class="secondary" type="button">GET /ready</button>
      <button id="quick-categories" class="secondary" type="button">GET /api/categories</button>
    </div>
    <p id="http-status" class="hint">No request yet.</p>
    <pre id="http-output"></pre>
  </section>

  <section class="card">
    <h2>WebSocket (/ws)</h2>
    <p class="hint">Connects with subprotocol <code>bearer,&lt;token&gt;</code>. Token is required.</p>
    <div class="row">
      <button id="ws-connect" type="button">Connect</button>
      <button id="ws-close" class="secondary" type="button">Close</button>
    </div>
    <label>WS Payload (JSON envelope)
      <textarea id="ws-payload">{"type":"ping"}</textarea>
    </label>
    <div class="row">
      <button id="ws-send" type="button">Send JSON</button>
      <button id="ws-ping" class="secondary" type="button">Send ping</button>
      <button id="ws-typing" class="secondary" type="button">Send typing</button>
      <button id="ws-read" class="secondary" type="button">Send read</button>
      <button id="ws-message" class="secondary" type="button">Send message</button>
    </div>
    <pre id="ws-output"></pre>
  </section>
</main>

<script>
  const el = (id) => document.getElementById(id);

  const presets = [
    { label: "Public: GET /health", method: "GET", path: "/health", auth: "no" },
    { label: "Public: GET /ready", method: "GET", path: "/ready", auth: "no" },
    { label: "Public: GET /metrics", method: "GET", path: "/metrics", auth: "no" },

    { label: "Auth: POST /api/auth/register", method: "POST", path: "/api/auth/register", auth: "no", body: { email: "owner@example.com", password: "VeryStrongPass123", username: "owner_user", full_name: "Owner User" } },
    { label: "Auth: POST /api/auth/login", method: "POST", path: "/api/auth/login", auth: "no", body: { email: "owner@example.com", password: "VeryStrongPass123" } },
    { label: "Auth: GET /api/auth/me", method: "GET", path: "/api/auth/me", auth: "yes" },
    { label: "Auth: POST /api/auth/verify-email", method: "POST", path: "/api/auth/verify-email", auth: "yes" },
    { label: "Auth: POST /api/auth/refresh", method: "POST", path: "/api/auth/refresh", auth: "no", body: { refresh_token: "paste-refresh-token" } },
    { label: "Auth: POST /api/auth/logout", method: "POST", path: "/api/auth/logout", auth: "no", body: { refresh_token: "paste-refresh-token" } },
    { label: "Auth: POST /api/auth/oauth/google", method: "POST", path: "/api/auth/oauth/google", auth: "no", body: { code: "oauth-code", state: "oauth-state" } },
    { label: "Auth: POST /api/auth/oauth/github", method: "POST", path: "/api/auth/oauth/github", auth: "no", body: { code: "oauth-code", state: "oauth-state" } },

    { label: "Users: GET /api/users/{user_id}", method: "GET", path: "/api/users/{user_id}", auth: "no" },
    { label: "Users: PUT /api/users/{user_id}", method: "PUT", path: "/api/users/{user_id}", auth: "yes", body: { username: "owner_user_updated", full_name: "Owner User Updated", avatar_url: "https://example.com/avatar.png" } },
    { label: "Users: GET /api/users/me/equipment", method: "GET", path: "/api/users/me/equipment", auth: "yes" },

    { label: "Categories: GET /api/categories", method: "GET", path: "/api/categories", auth: "no" },
    { label: "Categories: GET /api/categories/{category_id}", method: "GET", path: "/api/categories/{category_id}", auth: "no" },

    { label: "Equipment: GET /api/equipment", method: "GET", path: "/api/equipment", auth: "no" },
    { label: "Equipment: GET /api/equipment/{equipment_id}", method: "GET", path: "/api/equipment/{equipment_id}", auth: "no" },
    { label: "Equipment: POST /api/equipment", method: "POST", path: "/api/equipment", auth: "yes", body: { category_id: "{category_id}", title: "Camera body", description: "Well maintained camera body with battery and charger.", daily_rate: "35.50", condition: "good", location: "San Francisco, CA", coordinates: { latitude: 37.7749, longitude: -122.4194 } } },
    { label: "Equipment: PUT /api/equipment/{equipment_id}", method: "PUT", path: "/api/equipment/{equipment_id}", auth: "yes", body: { title: "Camera body mk2", description: "Updated listing text with additional detail.", daily_rate: "40.00", condition: "excellent", location: "San Jose, CA", is_available: true } },
    { label: "Equipment: DELETE /api/equipment/{equipment_id}", method: "DELETE", path: "/api/equipment/{equipment_id}", auth: "yes" },
    { label: "Equipment: POST /api/equipment/{equipment_id}/photos", method: "POST", path: "/api/equipment/{equipment_id}/photos", auth: "yes", body: { photo_url: "https://images.example.com/camera.jpg", is_primary: true } },
    { label: "Equipment: DELETE /api/equipment/{equipment_id}/photos/{photo_id}", method: "DELETE", path: "/api/equipment/{equipment_id}/photos/{photo_id}", auth: "yes" },

    { label: "Conversations: GET /api/conversations", method: "GET", path: "/api/conversations", auth: "yes" },
    { label: "Conversations: POST /api/conversations", method: "POST", path: "/api/conversations", auth: "yes", body: { participant_ids: ["{participant_id}"] } },
    { label: "Conversations: GET /api/conversations/{conversation_id}", method: "GET", path: "/api/conversations/{conversation_id}", auth: "yes" },
    { label: "Conversations: GET /api/conversations/{conversation_id}/messages", method: "GET", path: "/api/conversations/{conversation_id}/messages?limit=50&offset=0", auth: "yes" },
    { label: "Conversations: POST /api/conversations/{conversation_id}/messages", method: "POST", path: "/api/conversations/{conversation_id}/messages", auth: "yes", body: { content: "Hello from minimal frontend" } },
  ];

  const idValues = () => ({
    "{user_id}": el("user-id").value.trim(),
    "{category_id}": el("category-id").value.trim(),
    "{equipment_id}": el("equipment-id").value.trim(),
    "{photo_id}": el("photo-id").value.trim(),
    "{conversation_id}": el("conversation-id").value.trim(),
    "{participant_id}": el("participant-id").value.trim(),
  });

  const substituteIds = (text) => {
    let output = text;
    for (const [key, value] of Object.entries(idValues())) {
      output = output.replaceAll(key, value || key);
    }
    return output;
  };

  const fillPresetList = () => {
    const select = el("request-presets");
    presets.forEach((preset, index) => {
      const option = document.createElement("option");
      option.value = String(index);
      option.textContent = preset.label;
      select.appendChild(option);
    });
    select.value = "0";
    loadPreset();
  };

  const loadPreset = () => {
    const preset = presets[Number(el("request-presets").value)];
    el("request-method").value = preset.method;
    el("request-path").value = substituteIds(preset.path);
    el("use-auth").value = preset.auth || "no";
    el("request-body").value = preset.body ? substituteIds(JSON.stringify(preset.body, null, 2)) : "{}";
  };

  const parseJsonSafe = (text) => {
    try {
      return JSON.parse(text);
    } catch (_err) {
      return null;
    }
  };

  const maybeExtractUsefulIds = (payload) => {
    if (!payload || typeof payload !== "object") return;
    if (payload.access_token) el("access-token").value = payload.access_token;
    if (payload.user && payload.user.id) el("user-id").value = payload.user.id;

    if (payload.id && typeof payload.id === "string") {
      const path = el("request-path").value;
      if (path.includes("/equipment")) el("equipment-id").value = payload.id;
      if (path.includes("/categories")) el("category-id").value = payload.id;
      if (path.includes("/conversations")) el("conversation-id").value = payload.id;
    }
  };

  const sendRequest = async () => {
    const method = el("request-method").value.trim().toUpperCase();
    const rawPath = substituteIds(el("request-path").value.trim());
    const path = rawPath.startsWith("/") ? rawPath : `/${rawPath}`;
    const url = `${el("base-url").value.trim().replace(/\/$/, "")}${path}`;
    const headers = {};

    if (el("use-auth").value === "yes") {
      const token = el("access-token").value.trim();
      if (token) headers.Authorization = `Bearer ${token}`;
    }

    const csrf = el("csrf-token").value.trim();
    if (csrf) headers["x-csrf-token"] = csrf;

    const bodyRaw = el("request-body").value.trim();
    let body = undefined;
    if (!["GET", "HEAD"].includes(method) && bodyRaw && bodyRaw !== "{}") {
      headers["Content-Type"] = "application/json";
      body = substituteIds(bodyRaw);
    }

    el("http-status").className = "hint";
    el("http-status").textContent = `Sending ${method} ${url}`;

    try {
      const response = await fetch(url, {
        method,
        headers,
        body,
        credentials: "include",
      });

      const text = await response.text();
      const json = parseJsonSafe(text);
      maybeExtractUsefulIds(json);

      el("http-status").className = response.ok ? "hint ok" : "hint warn";
      el("http-status").textContent = `HTTP ${response.status} ${response.statusText}`;
      el("http-output").textContent = json ? JSON.stringify(json, null, 2) : (text || "(empty)");
    } catch (err) {
      el("http-status").className = "hint warn";
      el("http-status").textContent = "Network error";
      el("http-output").textContent = String(err);
    }
  };

  let socket = null;

  const wsLog = (message) => {
    const out = el("ws-output");
    out.textContent += `${new Date().toISOString()} ${message}\n`;
    out.scrollTop = out.scrollHeight;
  };

  const wsBase = () => {
    const base = el("base-url").value.trim().replace(/\/$/, "");
    return base.replace(/^http:/, "ws:").replace(/^https:/, "wss:");
  };

  const wsConnect = () => {
    const token = el("access-token").value.trim();
    if (!token) {
      wsLog("missing access token");
      return;
    }
    if (socket && socket.readyState <= 1) {
      wsLog("socket already open/connecting");
      return;
    }
    socket = new WebSocket(`${wsBase()}/ws`, ["bearer", token]);
    socket.onopen = () => wsLog("connected");
    socket.onmessage = (event) => wsLog(`recv: ${event.data}`);
    socket.onclose = (event) => wsLog(`closed code=${event.code} reason=${event.reason || "-"}`);
    socket.onerror = () => wsLog("error");
  };

  const wsSendRaw = () => {
    if (!socket || socket.readyState !== 1) {
      wsLog("socket is not connected");
      return;
    }
    const payload = el("ws-payload").value.trim();
    socket.send(payload);
    wsLog(`sent: ${payload}`);
  };

  const wsSendTemplate = (template) => {
    el("ws-payload").value = JSON.stringify(template, null, 2);
    wsSendRaw();
  };

  fillPresetList();
  el("load-preset").addEventListener("click", loadPreset);
  el("send-request").addEventListener("click", sendRequest);
  el("quick-health").addEventListener("click", () => {
    el("request-method").value = "GET";
    el("request-path").value = "/health";
    el("use-auth").value = "no";
    el("request-body").value = "{}";
    sendRequest();
  });
  el("quick-ready").addEventListener("click", () => {
    el("request-method").value = "GET";
    el("request-path").value = "/ready";
    el("use-auth").value = "no";
    el("request-body").value = "{}";
    sendRequest();
  });
  el("quick-categories").addEventListener("click", () => {
    el("request-method").value = "GET";
    el("request-path").value = "/api/categories";
    el("use-auth").value = "no";
    el("request-body").value = "{}";
    sendRequest();
  });

  el("ws-connect").addEventListener("click", wsConnect);
  el("ws-close").addEventListener("click", () => {
    if (socket) socket.close();
  });
  el("ws-send").addEventListener("click", wsSendRaw);
  el("ws-ping").addEventListener("click", () => wsSendTemplate({ type: "ping" }));
  el("ws-typing").addEventListener("click", () => wsSendTemplate({
    type: "typing",
    payload: { conversation_id: el("conversation-id").value.trim(), is_typing: true },
  }));
  el("ws-read").addEventListener("click", () => wsSendTemplate({
    type: "read",
    payload: { conversation_id: el("conversation-id").value.trim() },
  }));
  el("ws-message").addEventListener("click", () => wsSendTemplate({
    type: "message",
    payload: { conversation_id: el("conversation-id").value.trim(), content: "Hello via websocket" },
  }));
</script>
</body>
</html>
